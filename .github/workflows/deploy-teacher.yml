name: Deploy to Azure

on:
  workflow_run:
    workflows: ["Build Container with Buildah"]
    types: [completed]
    branches: [main]
  workflow_dispatch:

env:
  REGISTRY: ghcr.io

jobs:
  deploy:
    name: Deploy to Azure
    runs-on: ubuntu-latest
    if: ${{ github.event.workflow_run.conclusion == 'success' || github.event_name == 'workflow_dispatch' }}
    
    steps:
    - uses: actions/checkout@v5

    - name: Set image name
      id: image_name
      run: echo "name=$(echo '${{ github.repository }}' | tr '[:upper:]' '[:lower:]')" >> $GITHUB_OUTPUT

    - name: Extract metadata for consistent tagging
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ steps.image_name.outputs.name }}
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=sha,prefix={{branch}}-
          type=raw,value=latest,enable={{is_default_branch}}
          type=raw,value={{sha}},enable={{is_default_branch}}
          type=raw,value=stable,enable={{is_default_branch}}

    - name: Set deployment image
      id: image
      run: |
        # Use the EXACT same tags that were generated by the build workflow
        if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
          # For manual dispatch, use latest if on main, otherwise use branch name
          if [ "${{ github.ref }}" = "refs/heads/main" ]; then
            TAG="latest"
          else
            TAG="${{ github.ref_name }}"
          fi
        else
          # For automatic deployment after build, use the SHA-based tag that was actually created
          # The metadata-action uses SHORT SHA format, so we need to match that
          SHORT_SHA=$(echo "${{ github.sha }}" | cut -c1-7)
          TAG="${{ github.ref_name }}-$SHORT_SHA"
        fi
        
        echo "Full SHA: ${{ github.sha }}"
        echo "Short SHA: $(echo "${{ github.sha }}" | cut -c1-7)"
        echo "Selected tag: $TAG"
        echo "Full image: ${{ env.REGISTRY }}/${{ steps.image_name.outputs.name }}:$TAG"
        
        echo "image=${{ env.REGISTRY }}/${{ steps.image_name.outputs.name }}:$TAG" >> $GITHUB_OUTPUT
        echo "tag=$TAG" >> $GITHUB_OUTPUT
        echo "commit_sha=${{ github.sha }}" >> $GITHUB_OUTPUT

    - name: Verify image exists
      run: |
        echo "Verifying image exists: ${{ steps.image.outputs.image }}"
        
        # Login to registry for verification
        echo ${{ secrets.GITHUB_TOKEN }} | docker login ${{ env.REGISTRY }} -u ${{ github.actor }} --password-stdin
        
        # The image MUST exist since it was just built in the previous workflow
        # If it doesn't exist, that's a serious error in our build pipeline
        if ! docker manifest inspect "${{ steps.image.outputs.image }}" > /dev/null 2>&1; then
          echo "‚ùå CRITICAL ERROR: Image not found: ${{ steps.image.outputs.image }}"
          echo "This indicates a problem with the build workflow or tag synchronization."
          echo ""
          echo "Expected tag format: ${{ github.ref_name }}-${{ github.sha }}"
          echo "This should match what was created by the build workflow metadata action:"
          echo "  type=sha,prefix={{branch}}-"
          echo ""
          echo "Please check:"
          echo "1. Build workflow completed successfully"
          echo "2. Image was pushed to registry"
          echo "3. Tag formats match between build and deploy workflows"
          exit 1
        fi
        
        echo "‚úÖ Image verified: ${{ steps.image.outputs.image }}"
        echo "‚úÖ Proceeding with deployment"

    - name: Login to Azure
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}

    - name: Generate deployment config
      run: |
        echo "Generating deployment configuration..."
        
        # Generate base deployment config
        cat > deployment.json << EOF
        {
          "apiVersion": "2021-10-01",
          "location": "${{ vars.AZURE_LOCATION || 'eastus' }}",
          "name": "${{ vars.AZURE_CONTAINER_NAME || 'trading-course' }}",
          "properties": {
             "containers": [
               {
                 "name": "trading-app",
                 "properties": {
                   "image": "${{ steps.image.outputs.image }}",
                   "command": ["/exchange-server", "-config=/config.production.yaml"],
                   "ports": [
                     {
                       "protocol": "TCP",
                       "port": 80
                     }
                   ],
                   "environmentVariables": [
                     {
                       "name": "PORT",
                       "value": "80"
                     },
                     {
                       "name": "LOG_LEVEL",
                       "value": "${{ vars.LOG_LEVEL || 'info' }}"
                     },
                     {
                       "name": "MONGODB_URI",
                       "value": "${{ secrets.MONGODB_URI }}"
                     }
                   ],
                   "resources": {
                     "requests": {
                       "memoryInGB": ${{ vars.MEMORY_GB || 1 }},
                       "cpu": ${{ vars.CPU_CORES || 0.5 }}
                     }
                   }
                 }
               },

             ],
            "imageRegistryCredentials": [
              {
                "server": "${{ env.REGISTRY }}",
                "username": "${{ github.actor }}",
                "password": "${{ secrets.GHCR_PAT }}"
              }
            ],
            "ipAddress": {
              "type": "Public",
               "ports": [
                 {
                   "protocol": "TCP",
                   "port": 80
                 }
               ],
              "dnsNameLabel": "${{ vars.AZURE_CONTAINER_NAME || 'trading-course' }}"
            },
            "osType": "Linux",
            "restartPolicy": "Always",
             "volumes": []
        EOF
        
        # Configure Log Analytics if available
        if [ "$LOG_ANALYTICS_ENABLED" = "true" ]; then
          echo "Adding Log Analytics configuration..."
          cat >> deployment.json << EOF
            ,
            "diagnostics": {
              "logAnalytics": {
                "workspaceId": "$LOG_ANALYTICS_WORKSPACE_ID"
              }
            }
        EOF
        else
          echo "Log Analytics not available - proceeding without"
        fi
        
        # Close the JSON
        cat >> deployment.json << EOF
          },
          "type": "Microsoft.ContainerInstance/containerGroups"
        }
        EOF

    - name: Setup Log Analytics for Portal Integration
      run: |
        echo "Setting up Azure Log Analytics for Portal-compatible logging..."
        
        RESOURCE_GROUP="${{ vars.AZURE_RESOURCE_GROUP || 'trading-course-rg' }}"
        WORKSPACE_NAME="${{ vars.LOG_ANALYTICS_WORKSPACE || 'trading-course-logs' }}"
        LOCATION="${{ vars.AZURE_LOCATION || 'eastus' }}"
        
        # Create or get Log Analytics workspace
        echo "Ensuring Log Analytics workspace exists..."
        az monitor log-analytics workspace create \
          --resource-group "$RESOURCE_GROUP" \
          --workspace-name "$WORKSPACE_NAME" \
          --location "$LOCATION" \
          --sku PerGB2018 \
          --only-show-errors || echo "Workspace may already exist"
        
        # Get workspace details
        WORKSPACE_ID=$(az monitor log-analytics workspace show \
          --resource-group "$RESOURCE_GROUP" \
          --workspace-name "$WORKSPACE_NAME" \
          --query customerId \
          --output tsv)
        
        if [ -n "$WORKSPACE_ID" ] && [ "$WORKSPACE_ID" != "null" ]; then
          echo "‚úÖ Log Analytics Workspace ready"
          echo "Workspace ID: $WORKSPACE_ID"
          echo "LOG_ANALYTICS_WORKSPACE_ID=$WORKSPACE_ID" >> $GITHUB_ENV
          echo "LOG_ANALYTICS_ENABLED=true" >> $GITHUB_ENV
        else
          echo "‚ùå Failed to create/access Log Analytics workspace"
          echo "LOG_ANALYTICS_ENABLED=false" >> $GITHUB_ENV
        fi

    - name: Deploy container for Portal-compatible logging
      run: |
        echo "Deploying WebSocket application with Portal-compatible configuration..."
        echo "Image: ${{ steps.image.outputs.image }}"
        echo "Registry: ${{ env.REGISTRY }}"
        echo "Username: ${{ github.actor }}"
        
        RESOURCE_GROUP="${{ vars.AZURE_RESOURCE_GROUP || 'trading-course-rg' }}"
        CONTAINER_NAME="${{ vars.AZURE_CONTAINER_NAME || 'trading-course' }}"
        
        # Delete existing container
        echo "Removing existing container..."
        az container delete \
          --resource-group "$RESOURCE_GROUP" \
          --name "$CONTAINER_NAME" \
          --yes || true
        
        sleep 10
        
        # Create container with CLI for Portal compatibility (no JSON config file)
        echo "Creating container with Portal-compatible configuration..."
        
        DEPLOY_CMD="az container create \
          --resource-group '$RESOURCE_GROUP' \
          --name '$CONTAINER_NAME' \
          --image '${{ steps.image.outputs.image }}' \
          --location '${{ vars.AZURE_LOCATION || 'eastus' }}' \
          --dns-name-label '$CONTAINER_NAME' \
          --ports 80 \
          --protocol TCP \
          --cpu ${{ vars.CPU_CORES || 0.5 }} \
          --memory ${{ vars.MEMORY_GB || 1 }} \
          --restart-policy Always \
          --environment-variables PORT=80 LOG_LEVEL=${{ vars.LOG_LEVEL || 'info' }} \
          --secure-environment-variables MONGODB_URI='${{ secrets.MONGODB_URI }}' \
          --registry-server '${{ env.REGISTRY }}' \
          --registry-username '${{ github.actor }}' \
          --registry-password '${{ secrets.GHCR_PAT }}' \
          --command-line '/exchange-server -config=/config.production.yaml'"
        
        # Add Log Analytics if available
        if [ "$LOG_ANALYTICS_ENABLED" = "true" ]; then
          echo "Adding Log Analytics workspace integration..."
          DEPLOY_CMD="$DEPLOY_CMD --log-analytics-workspace '$LOG_ANALYTICS_WORKSPACE_ID'"
        fi
        
        echo "Executing deployment command..."
        eval "$DEPLOY_CMD"
        
        echo ""
        echo "‚úÖ Container deployment completed!"
        
        if [ "$LOG_ANALYTICS_ENABLED" = "true" ]; then
          echo "‚úÖ Log Analytics integration enabled"
          echo "üìä Container logs will be available in Azure Portal"
        else
          echo "‚ö†Ô∏è  Log Analytics not configured"
        fi
        
        echo ""
        echo "WebSocket Application Deployment:"
        echo "================================="
        echo "- HTTP WebSocket support enabled"
        echo "- Trading UI: Available at root path"  
        echo "- Direct application access on port 80 (Cloudflare compatible)"
        echo "- Portal-compatible logging configuration"
        echo "- Cloudflare-ready for free HTTPS"
        echo ""
        echo "Access Information:"
        echo "=================="
        echo "Direct access: http://[CONTAINER_FQDN]/"
        echo "WebSocket: ws://[CONTAINER_FQDN]/ws"
        echo ""
        echo "Cloudflare DNS Automation:"
        echo "‚úÖ DNS record will be updated automatically"
        echo "‚úÖ HTTPS will be available via Cloudflare proxy"
        echo ""
        echo "After automation completes:"
        echo "Website: https://trading.hellsoft.tech/"
        echo "WebSocket: wss://trading.hellsoft.tech/ws"
        echo ""
        echo "Azure Portal Logs:"
        if [ "$LOG_ANALYTICS_ENABLED" = "true" ]; then
          echo "‚úÖ Available in Container Instances ‚Üí $CONTAINER_NAME ‚Üí Logs"
        else
          echo "‚ö†Ô∏è  Log Analytics workspace required for Portal log viewing"
        fi

    - name: Health check
      run: |
        sleep 60
        
        CONTAINER_NAME="${{ vars.AZURE_CONTAINER_NAME || 'trading-course' }}"
        RESOURCE_GROUP="${{ vars.AZURE_RESOURCE_GROUP || 'trading-course-rg' }}"
        
        for i in {1..5}; do
          STATE=$(az container show \
            --resource-group "$RESOURCE_GROUP" \
            --name "$CONTAINER_NAME" \
            --query 'instanceView.state' \
            --output tsv)
          
          if [ "$STATE" = "Running" ]; then
            echo "‚úÖ Container is running"
            break
          elif [ "$STATE" = "Failed" ]; then
            echo "‚ùå Container failed"
            az container logs --resource-group "$RESOURCE_GROUP" --name "$CONTAINER_NAME"
            exit 1
          fi
          
          echo "Waiting... ($i/5)"
          sleep 20
        done

    - name: Get deployment info
      run: |
        CONTAINER_NAME="${{ vars.AZURE_CONTAINER_NAME || 'trading-course' }}"
        RESOURCE_GROUP="${{ vars.AZURE_RESOURCE_GROUP || 'trading-course-rg' }}"
        
        INFO=$(az container show \
          --resource-group "$RESOURCE_GROUP" \
          --name "$CONTAINER_NAME" \
          --query '{fqdn: ipAddress.fqdn, ip: ipAddress.ip, state: instanceView.state}' \
          --output json)
        
        echo "Container Info:"
        echo "$INFO" | jq
        
        IP=$(echo "$INFO" | jq -r '.ip')
        FQDN=$(echo "$INFO" | jq -r '.fqdn')
        
        echo ""
        echo "=== CLOUDFLARE SETUP ==="
        echo "1. Add this DNS record in Cloudflare:"
        echo "   Type: A"
        echo "   Name: trading (or @)"  
        echo "   Content: $IP"
        echo "   Proxy: Enabled (orange cloud)"
        echo ""
        echo "2. SSL/TLS Settings:"
        echo "   Mode: Flexible"
        echo "   Always Use HTTPS: On"
        echo ""
        echo "3. After setup, access via:"
        echo "   https://trading.hellsoft.tech/"
        echo "   wss://trading.hellsoft.tech/ws"
        echo ""
        echo "Direct access (for testing):"
        echo "   http://$FQDN/"
        
        # Export container IP for Cloudflare DNS update
        echo "CONTAINER_IP=$IP" >> $GITHUB_ENV
        echo "CONTAINER_FQDN=$FQDN" >> $GITHUB_ENV

    - name: Update Cloudflare DNS
      if: env.CONTAINER_IP != '' && env.CONTAINER_IP != 'null'
      run: |
        echo "Updating Cloudflare DNS record..."
        
        # DNS record configuration
        ZONE_ID="${{ secrets.CLOUDFLARE_ZONE_ID }}"
        API_TOKEN="${{ secrets.CLOUDFLARE_API_TOKEN }}"
        DOMAIN_NAME="trading.hellsoft.tech"
        RECORD_TYPE="A"
        RECORD_CONTENT="${{ env.CONTAINER_IP }}"
        TTL=1  # Auto (proxied)
        PROXIED=true
        
        if [ -z "$ZONE_ID" ] || [ -z "$API_TOKEN" ]; then
          echo "Cloudflare credentials not configured - skipping DNS update"
          echo "To enable automatic DNS updates:"
          echo "1. Add CLOUDFLARE_ZONE_ID to GitHub secrets"
          echo "2. Add CLOUDFLARE_API_TOKEN to GitHub secrets"
          exit 0
        fi
        
        echo "Zone ID: $ZONE_ID"
        echo "Domain: $DOMAIN_NAME"
        echo "New IP: $RECORD_CONTENT"
        
        # Check if DNS record exists
        echo "Checking for existing DNS record..."
        RECORD_ID=$(curl -s -X GET "https://api.cloudflare.com/client/v4/zones/$ZONE_ID/dns_records?type=$RECORD_TYPE&name=$DOMAIN_NAME" \
          -H "Authorization: Bearer $API_TOKEN" \
          -H "Content-Type: application/json" | \
          jq -r '.result[0].id // empty')
        
        if [ -n "$RECORD_ID" ] && [ "$RECORD_ID" != "null" ]; then
          echo "Existing DNS record found (ID: $RECORD_ID)"
          echo "Updating existing record..."
          
          # Update existing record
          RESPONSE=$(curl -s -X PUT "https://api.cloudflare.com/client/v4/zones/$ZONE_ID/dns_records/$RECORD_ID" \
            -H "Authorization: Bearer $API_TOKEN" \
            -H "Content-Type: application/json" \
            --data '{
              "type": "'$RECORD_TYPE'",
              "name": "'$DOMAIN_NAME'",
              "content": "'$RECORD_CONTENT'",
              "ttl": '$TTL',
              "proxied": '$PROXIED'
            }')
          
          SUCCESS=$(echo "$RESPONSE" | jq -r '.success')
          if [ "$SUCCESS" = "true" ]; then
            echo "‚úÖ DNS record updated successfully!"
            echo "   $DOMAIN_NAME -> $RECORD_CONTENT (proxied)"
            echo "   Record ID: $(echo "$RESPONSE" | jq -r '.result.id')"
            echo "   Proxied: $(echo "$RESPONSE" | jq -r '.result.proxied')"
          else
            echo "‚ùå Failed to update DNS record:"
            echo "$RESPONSE" | jq '.errors[]?.message // .errors // .'
            exit 1
          fi
        else
          echo "No existing DNS record found"
          echo "Creating new DNS record..."
          
          # Create new record
          RESPONSE=$(curl -s -X POST "https://api.cloudflare.com/client/v4/zones/$ZONE_ID/dns_records" \
            -H "Authorization: Bearer $API_TOKEN" \
            -H "Content-Type: application/json" \
            --data '{
              "type": "'$RECORD_TYPE'",
              "name": "'$DOMAIN_NAME'",
              "content": "'$RECORD_CONTENT'",
              "ttl": '$TTL',
              "proxied": '$PROXIED'
            }')
          
          SUCCESS=$(echo "$RESPONSE" | jq -r '.success')
          if [ "$SUCCESS" = "true" ]; then
            NEW_RECORD_ID=$(echo "$RESPONSE" | jq -r '.result.id')
            echo "‚úÖ DNS record created successfully!"
            echo "   Record ID: $NEW_RECORD_ID"
            echo "   $DOMAIN_NAME -> $RECORD_CONTENT (proxied)"
            echo "   Proxied: $(echo "$RESPONSE" | jq -r '.result.proxied')"
          else
            echo "‚ùå Failed to create DNS record:"
            echo "$RESPONSE" | jq '.errors[]?.message // .errors // .'
            exit 1
          fi
        fi
        
        # Wait for DNS propagation
        echo ""
        echo "Waiting for DNS propagation..."
        sleep 30
        
        # Verify DNS update (accounting for Cloudflare proxy)
        echo "Verifying DNS update..."
        for i in {1..5}; do
          RESOLVED_IP=$(dig +short "$DOMAIN_NAME" @1.1.1.1 | tail -n1)
          
          # Check if we get Cloudflare IPs (indicating proxied record is working)
          if echo "$RESOLVED_IP" | grep -qE "^(104\.2[0-1]\.|172\.6[4-7]\.|188\.114\.)"; then
            echo "‚úÖ DNS proxied through Cloudflare: $DOMAIN_NAME -> $RESOLVED_IP (Cloudflare IP)"
            echo "‚úÖ Origin server IP ($RECORD_CONTENT) correctly configured behind proxy"
            break
          elif [ "$RESOLVED_IP" = "$RECORD_CONTENT" ]; then
            echo "‚úÖ DNS direct resolution: $DOMAIN_NAME -> $RESOLVED_IP"
            echo "‚ö†Ô∏è  Note: Record appears to be unproxied (gray cloud)"
            break
          else
            echo "DNS propagation attempt $i/5: $RESOLVED_IP"
            if [ $i -lt 5 ]; then
              sleep 15
            else
              echo "‚ö†Ô∏è  DNS verification inconclusive, but record was updated in Cloudflare"
              echo "The DNS record update was successful in Cloudflare's API"
            fi
          fi
        done
        
        echo ""
        echo "üéâ Cloudflare DNS automation completed!"
        echo ""
        echo "üìã What was configured:"
        echo "  ‚Ä¢ A record: $DOMAIN_NAME -> $RECORD_CONTENT"
        echo "  ‚Ä¢ Proxy: Enabled (orange cloud)"
        echo "  ‚Ä¢ SSL: Handled by Cloudflare"
        echo ""
        echo "üåê Public resolution:"
        echo "  ‚Ä¢ DNS queries return Cloudflare proxy IPs (expected)"
        echo "  ‚Ä¢ Cloudflare routes traffic to your container IP"
        echo "  ‚Ä¢ HTTPS/SSL termination handled by Cloudflare"
        echo ""
        echo "üîó Your site should be accessible at:"
        echo "  https://$DOMAIN_NAME"

    - name: Extended health check
      id: health_check
      run: |
        CONTAINER_NAME="${{ vars.AZURE_CONTAINER_NAME || 'trading-course' }}"
        RESOURCE_GROUP="${{ vars.AZURE_RESOURCE_GROUP || 'trading-course-rg' }}"
        
        echo "Performing extended health check..."
        
        # Wait for container to be fully ready
        sleep 120
        
        # Check container is still running
        STATE=$(az container show \
          --resource-group "$RESOURCE_GROUP" \
          --name "$CONTAINER_NAME" \
          --query 'instanceView.state' \
          --output tsv)
        
        if [ "$STATE" != "Running" ]; then
          echo "‚ùå Container not running: $STATE"
          exit 1
        fi
        
        # Get container info for health check
        INFO=$(az container show \
          --resource-group "$RESOURCE_GROUP" \
          --name "$CONTAINER_NAME" \
          --query '{fqdn: ipAddress.fqdn, ip: ipAddress.ip}' \
          --output json)
        
        FQDN=$(echo "$INFO" | jq -r '.fqdn')
        
         if [ "$FQDN" != "null" ] && [ -n "$FQDN" ]; then
           # Test HTTP endpoint on port 80
           echo "Testing HTTP endpoint: http://$FQDN"
           if curl --fail --max-time 30 --retry 3 --retry-delay 10 "http://$FQDN" > /dev/null 2>&1; then
             echo "‚úÖ HTTP health check passed"
           else
             echo "‚ùå HTTP health check failed"
             echo "Note: This is expected until Cloudflare proxy is configured"
           fi
         fi
        
        echo "‚úÖ Extended health check completed"
        echo "healthy=true" >> $GITHUB_OUTPUT

    - name: Test Cloudflare HTTPS
      if: env.CONTAINER_IP != '' && env.CONTAINER_IP != 'null'
      run: |
        DOMAIN_NAME="trading.hellsoft.tech"
        
        if [ -z "${{ secrets.CLOUDFLARE_API_TOKEN }}" ]; then
          echo "Cloudflare not configured - skipping HTTPS test"
          exit 0
        fi
        
        echo "Testing HTTPS access through Cloudflare..."
        echo "Waiting for Cloudflare proxy to pick up changes..."
        sleep 60
        
        # Test HTTPS access
        for i in {1..3}; do
          echo "Attempt $i/3: Testing https://$DOMAIN_NAME"
          
          if curl -s -f -m 30 "https://$DOMAIN_NAME" > /dev/null; then
            echo "‚úÖ HTTPS access successful!"
            echo "üéâ Your trading application is live at: https://$DOMAIN_NAME"
            
            # Test WebSocket over WSS
            echo "Testing WebSocket SSL support..."
            if curl -s -f -m 10 -H "Connection: Upgrade" -H "Upgrade: websocket" "https://$DOMAIN_NAME/ws" 2>/dev/null; then
              echo "‚úÖ WebSocket SSL (WSS) support confirmed"
            else
              echo "‚ö†Ô∏è  WebSocket SSL test inconclusive (expected for some setups)"
            fi
            
            echo ""
            echo "üåü DEPLOYMENT COMPLETE üåü"
            echo "=========================="
            echo "‚úÖ Container deployed and running"
            echo "‚úÖ DNS automatically updated"
            echo "‚úÖ HTTPS enabled via Cloudflare"
            echo "‚úÖ WebSocket support enabled"
            echo ""
            echo "üîó Access your trading application:"
            echo "   https://$DOMAIN_NAME"
            echo ""
            echo "üîå WebSocket endpoint:"
            echo "   wss://$DOMAIN_NAME/ws"
            
            break
          else
            echo "‚ùå HTTPS test failed (attempt $i/3)"
            if [ $i -lt 3 ]; then
              echo "Waiting 30 seconds before retry..."
              sleep 30
            else
              echo ""
              echo "‚ö†Ô∏è  HTTPS test failed after 3 attempts"
              echo "This could be due to:"
              echo "- DNS propagation delay (try again in a few minutes)"
              echo "- Cloudflare proxy setup issues"
              echo "- SSL certificate provisioning delay"
              echo ""
              echo "Manual verification:"
              echo "1. Check DNS: dig trading.hellsoft.tech"
              echo "2. Test direct: http://${{ env.CONTAINER_FQDN }}"
              echo "3. Test HTTPS: https://$DOMAIN_NAME (may take 5-10 minutes)"
            fi
          fi
        done

    - name: Verify Portal Log Integration
      run: |
        CONTAINER_NAME="${{ vars.AZURE_CONTAINER_NAME || 'trading-course' }}"
        RESOURCE_GROUP="${{ vars.AZURE_RESOURCE_GROUP || 'trading-course-rg' }}"
        
        echo "Portal Log Integration Verification"
        echo "==================================="
        
        # Check container configuration
        echo "Checking container logging configuration..."
        LOGGING_CONFIG=$(az container show \
          --resource-group "$RESOURCE_GROUP" \
          --name "$CONTAINER_NAME" \
          --query 'properties.diagnostics.logAnalytics.workspaceId' \
          --output tsv 2>/dev/null || echo "none")
        
        if [ "$LOGGING_CONFIG" != "none" ] && [ "$LOGGING_CONFIG" != "null" ] && [ -n "$LOGGING_CONFIG" ]; then
          echo "‚úÖ Log Analytics integration detected"
          echo "Workspace ID: $LOGGING_CONFIG"
          echo ""
          echo "üìä How to View Logs in Azure Portal:"
          echo "1. Go to Azure Portal"
          echo "2. Navigate to Container Instances"
          echo "3. Select '$CONTAINER_NAME'"
          echo "4. Click 'Logs' in the left sidebar"
          echo "5. Logs should be available without CLI requirement"
          echo ""
          echo "üìà Sample Log Analytics Queries:"
          echo "# View all container logs (last hour)"
          echo "ContainerInstanceLog_CL"
          echo "| where TimeGenerated > ago(1h)"
          echo "| order by TimeGenerated desc"
          echo ""
          echo "# Filter by log level"
          echo "ContainerInstanceLog_CL"
          echo "| where Message contains 'ERROR' or Message contains 'WARN'"
          echo "| order by TimeGenerated desc"
        else
          echo "‚ö†Ô∏è  Portal Log Analytics integration not detected"
          echo "Container logs available via Azure CLI only:"
          echo ""
          echo "az container logs \\"
          echo "  --resource-group $RESOURCE_GROUP \\"
          echo "  --name $CONTAINER_NAME"
          echo ""
          echo "Note: For Portal log viewing, ensure Log Analytics workspace"
          echo "is properly configured and the container deployment method"
          echo "is compatible with Portal integration."
        fi
        
        echo ""
        echo "üîç Current Container Status:"
        az container show \
          --resource-group "$RESOURCE_GROUP" \
          --name "$CONTAINER_NAME" \
          --query '{state: instanceView.state, restartCount: containers[0].instanceView.restartCount, logs: properties.diagnostics}' \
          --output table

    - name: SSL Certificate Status Check
      id: ssl_check
      run: |
        CONTAINER_NAME="${{ vars.AZURE_CONTAINER_NAME || 'trading-course' }}"
        RESOURCE_GROUP="${{ vars.AZURE_RESOURCE_GROUP || 'trading-course-rg' }}"
        DOMAIN="${{ vars.DOMAIN_NAME || 'your-domain.com' }}"
        
        echo "Comprehensive SSL Certificate Status Check"
        echo "============================================="
        
        # Get container FQDN
        INFO=$(az container show \
          --resource-group "$RESOURCE_GROUP" \
          --name "$CONTAINER_NAME" \
          --query '{fqdn: ipAddress.fqdn, ip: ipAddress.ip}' \
          --output json)
        
        FQDN=$(echo "$INFO" | jq -r '.fqdn')
        IP=$(echo "$INFO" | jq -r '.ip')
        
        echo "Container FQDN: $FQDN"
        echo "Container IP: $IP"
        echo "Target Domain: $DOMAIN"
        echo ""
        
        # Check if domain points to container (accounting for Cloudflare proxy)
        if [ "$DOMAIN" != "your-domain.com" ]; then
          echo "DNS Resolution Check:"
          RESOLVED_IP=$(dig +short "$DOMAIN" A | tail -n1)
          echo "  $DOMAIN resolves to: $RESOLVED_IP"
          echo "  Container IP: $IP"
          
          # Check if DNS is proxied through Cloudflare
          if echo "$RESOLVED_IP" | grep -qE "^(104\.2[0-1]\.|172\.6[4-7]\.|188\.114\.)"; then
            echo "  ‚úÖ DNS proxied through Cloudflare (expected for HTTPS)"
            echo "  ‚úÖ Origin IP ($IP) configured behind Cloudflare proxy"
          elif [ "$RESOLVED_IP" = "$IP" ]; then
            echo "  ‚úÖ DNS points directly to container"
            echo "  ‚ö†Ô∏è  Note: For HTTPS, enable Cloudflare proxy (orange cloud)"
          else
            echo "  ‚ùå DNS issue - unexpected IP resolution"
            echo "  Expected: Cloudflare proxy IPs or direct container IP ($IP)"
          fi
          echo ""
          
          # Check SSL certificate on custom domain
          echo "SSL Certificate Check for $DOMAIN:"
          if timeout 10 openssl s_client -connect "$DOMAIN:443" -servername "$DOMAIN" < /dev/null 2>/dev/null; then
            echo "  ‚úÖ SSL connection successful"
            
            # Get certificate details
            CERT_INFO=$(timeout 10 openssl s_client -connect "$DOMAIN:443" -servername "$DOMAIN" < /dev/null 2>/dev/null | openssl x509 -noout -subject -issuer -dates 2>/dev/null)
            if [ $? -eq 0 ]; then
              echo "  üìã Certificate Details:"
              echo "$CERT_INFO" | sed 's/^/    /'
              
              # Check expiration
              EXPIRY=$(echo "$CERT_INFO" | grep "notAfter" | cut -d= -f2-)
              echo "  üìÖ Expires: $EXPIRY"
              
              # Check if Let's Encrypt
              if echo "$CERT_INFO" | grep -q "Let's Encrypt"; then
                echo "  üéØ Issuer: Let's Encrypt (auto-renewal enabled)"
              fi
            fi
          else
            echo "  ‚ùå No SSL certificate found or connection failed"
            echo "  Possible causes:"
            echo "    - Let's Encrypt still provisioning (can take 5-10 minutes)"
            echo "    - DNS not pointing to container"
            echo "    - nginx-proxy not configured properly"
          fi
        fi
        
         echo ""
         echo "Container Logs (trading-app):"
         az container logs \
           --resource-group "$RESOURCE_GROUP" \
           --name "$CONTAINER_NAME" \
           --container-name trading-app \
           --tail 20 || echo "  ‚ùå trading-app container logs not available"
        
         echo ""
         echo "Current Deployment Status:"
         echo "  HTTP (port 80): Available at http://$FQDN"
         echo "  Cloudflare HTTPS: Will be available at https://trading.hellsoft.tech"
         echo "  WebSocket: Available at ws://$FQDN/ws"
         if [ "$DOMAIN" != "your-domain.com" ] && [ -n "${{ vars.DOMAIN_NAME }}" ]; then
           echo "  Custom Domain HTTPS: https://$DOMAIN (after DNS setup)"
         fi
         echo "  SSL Auto-renewal: $([ -n "$(az container show --resource-group "$RESOURCE_GROUP" --name "$CONTAINER_NAME" --query 'properties.containers[?name==`certbot`]' --output tsv)" ] && echo "Enabled" || echo "Disabled")"

    - name: Save deployment metadata
      if: steps.health_check.outputs.healthy == 'true'
      run: |
        echo "Saving deployment metadata..."
        
        cat > deployment-metadata.json << EOF
        {
          "deployment_time": "$(date -u +"%Y-%m-%dT%H:%M:%SZ")",
          "commit_sha": "${{ steps.image.outputs.commit_sha }}",
          "image": "${{ steps.image.outputs.image }}",
          "tag": "${{ steps.image.outputs.tag }}",
          "workflow_run_id": "${{ github.run_id }}",
          "actor": "${{ github.actor }}",
          "ref": "${{ github.ref }}",
          "event": "${{ github.event_name }}"
        }
        EOF
        
        echo "Deployment metadata:"
        cat deployment-metadata.json | jq .

    - name: Upload deployment metadata
      if: steps.health_check.outputs.healthy == 'true'
      uses: actions/upload-artifact@v4
      with:
        name: deployment-metadata-${{ github.run_id }}
        path: deployment-metadata.json

    - name: Promote to stable
      if: steps.health_check.outputs.healthy == 'true' && github.ref == 'refs/heads/main'
      run: |
        echo "Promoting deployment to stable tag..."
        
        # Login to registry
        echo ${{ secrets.GITHUB_TOKEN }} | docker login ${{ env.REGISTRY }} -u ${{ github.actor }} --password-stdin
        
        # Current deployment image
        CURRENT_IMAGE="${{ steps.image.outputs.image }}"
        STABLE_IMAGE="${{ env.REGISTRY }}/${{ steps.image_name.outputs.name }}:stable"
        PREVIOUS_STABLE_IMAGE="${{ env.REGISTRY }}/${{ steps.image_name.outputs.name }}:stable-previous"
        
        # Backup current stable tag as stable-previous
        if docker manifest inspect "$STABLE_IMAGE" > /dev/null 2>&1; then
          echo "Backing up current stable as stable-previous..."
          docker pull "$STABLE_IMAGE"
          docker tag "$STABLE_IMAGE" "$PREVIOUS_STABLE_IMAGE"
          docker push "$PREVIOUS_STABLE_IMAGE"
        fi
        
        # Pull and tag the new stable image
        echo "Pulling: $CURRENT_IMAGE"
        docker pull "$CURRENT_IMAGE"
        
        echo "Tagging as stable: $STABLE_IMAGE"
        docker tag "$CURRENT_IMAGE" "$STABLE_IMAGE"
        
        # Push new stable tag
        echo "Pushing stable tag..."
        docker push "$STABLE_IMAGE"
        
        echo "‚úÖ Successfully promoted ${{ steps.image.outputs.commit_sha }} to stable"
        echo "‚úÖ Previous stable backed up as stable-previous"

  rollback:
    name: Rollback on failure
    runs-on: ubuntu-latest
    needs: deploy
    if: failure()
    
    steps:
    - name: Login to Azure
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}

    - name: Set rollback image name
      id: rollback_image
      run: echo "name=$(echo '${{ github.repository }}' | tr '[:upper:]' '[:lower:]')" >> $GITHUB_OUTPUT

    - name: Rollback to stable image
      run: |
        echo "Deployment failed, attempting rollback to stable..."
        
        # Try to use stable tag first, fallback to latest
        ROLLBACK_IMAGE="${{ env.REGISTRY }}/${{ steps.rollback_image.outputs.name }}:stable"
        
        # Verify stable image exists
        if ! docker manifest inspect "$ROLLBACK_IMAGE" > /dev/null 2>&1; then
          echo "Stable image not found, using latest..."
          ROLLBACK_IMAGE="${{ env.REGISTRY }}/${{ steps.rollback_image.outputs.name }}:latest"
        fi
        
        echo "Rolling back to: $ROLLBACK_IMAGE"
        
        # Generate rollback deployment config
        cat > rollback-deployment.json << EOF
        {
          "apiVersion": "2021-10-01",
          "location": "${{ vars.AZURE_LOCATION || 'eastus' }}",
          "name": "${{ vars.AZURE_CONTAINER_NAME || 'trading-course' }}",
          "properties": {
            "containers": [
              {
                "name": "trading-app",
                "properties": {
                  "image": "$ROLLBACK_IMAGE",
                  "command": ["/exchange-server", "-config=/config.production.yaml"],
                  "ports": [
                    {
                      "protocol": "TCP",
                      "port": 8080
                    }
                  ],
                  "environmentVariables": [
                    {
                      "name": "MONGODB_URI",
                      "secureValue": "${{ secrets.MONGODB_URI }}"
                    },
                    {
                      "name": "PORT", 
                      "value": "8080"
                    }
                  ],
                  "resources": {
                    "requests": {
                      "memoryInGB": ${{ vars.MEMORY_GB || 1 }},
                      "cpu": ${{ vars.CPU_CORES || 0.5 }}
                    }
                  }
                }
              }
            ],
            "imageRegistryCredentials": [
              {
                "server": "${{ env.REGISTRY }}",
                "username": "${{ github.actor }}",
                "password": "${{ secrets.GHCR_PAT }}"
              }
            ],
            "ipAddress": {
              "type": "Public",
              "ports": [
                {
                  "protocol": "TCP",
                  "port": 8080
                }
              ],
              "dnsNameLabel": "${{ vars.AZURE_CONTAINER_NAME || 'trading-course' }}"
            },
            "osType": "Linux",
            "restartPolicy": "Always"
          },
          "type": "Microsoft.ContainerInstance/containerGroups"
        }
        EOF
        
        # Delete failed container and deploy rollback
        az container delete \
          --resource-group ${{ vars.AZURE_RESOURCE_GROUP || 'trading-course-rg' }} \
          --name ${{ vars.AZURE_CONTAINER_NAME || 'trading-course' }} \
          --yes || true
        
        sleep 10
        
        az container create \
          --resource-group ${{ vars.AZURE_RESOURCE_GROUP || 'trading-course-rg' }} \
          --file rollback-deployment.json || echo "‚ùå Rollback failed"