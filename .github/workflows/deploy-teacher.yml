name: Deploy to Azure

on:
  workflow_run:
    workflows: ["Build Container with Buildah"]
    types: [completed]
    branches: [main]
  workflow_dispatch:

env:
  REGISTRY: ghcr.io

jobs:
  deploy:
    name: Deploy to Azure
    runs-on: ubuntu-latest
    if: ${{ github.event.workflow_run.conclusion == 'success' || github.event_name == 'workflow_dispatch' }}
    
    steps:
    - uses: actions/checkout@v5

    - name: Set image name
      id: image_name
      run: echo "name=$(echo '${{ github.repository }}' | tr '[:upper:]' '[:lower:]')" >> $GITHUB_OUTPUT

    - name: Extract metadata for consistent tagging
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ steps.image_name.outputs.name }}
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=sha,prefix={{branch}}-
          type=raw,value=latest,enable={{is_default_branch}}
          type=raw,value={{sha}},enable={{is_default_branch}}
          type=raw,value=stable,enable={{is_default_branch}}

    - name: Set deployment image
      id: image
      run: |
        # Use the EXACT same tags that were generated by the build workflow
        if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
          # For manual dispatch, use latest if on main, otherwise use branch name
          if [ "${{ github.ref }}" = "refs/heads/main" ]; then
            TAG="latest"
          else
            TAG="${{ github.ref_name }}"
          fi
        else
          # For automatic deployment after build, use the SHA-based tag that was actually created
          # This matches the build workflow: type=sha,prefix={{branch}}-
          TAG="${{ github.ref_name }}-${{ github.sha }}"
        fi
        
        echo "Selected tag: $TAG"
        echo "Full image: ${{ env.REGISTRY }}/${{ steps.image_name.outputs.name }}:$TAG"
        
        echo "image=${{ env.REGISTRY }}/${{ steps.image_name.outputs.name }}:$TAG" >> $GITHUB_OUTPUT
        echo "tag=$TAG" >> $GITHUB_OUTPUT
        echo "commit_sha=${{ github.sha }}" >> $GITHUB_OUTPUT

    - name: Verify image exists
      run: |
        echo "Verifying image exists: ${{ steps.image.outputs.image }}"
        
        # Login to registry for verification
        echo ${{ secrets.GITHUB_TOKEN }} | docker login ${{ env.REGISTRY }} -u ${{ github.actor }} --password-stdin
        
        # The image MUST exist since it was just built in the previous workflow
        # If it doesn't exist, that's a serious error in our build pipeline
        if ! docker manifest inspect "${{ steps.image.outputs.image }}" > /dev/null 2>&1; then
          echo "âŒ CRITICAL ERROR: Image not found: ${{ steps.image.outputs.image }}"
          echo "This indicates a problem with the build workflow or tag synchronization."
          echo ""
          echo "Expected tag format: ${{ github.ref_name }}-${{ github.sha }}"
          echo "This should match what was created by the build workflow metadata action:"
          echo "  type=sha,prefix={{branch}}-"
          echo ""
          echo "Please check:"
          echo "1. Build workflow completed successfully"
          echo "2. Image was pushed to registry"
          echo "3. Tag formats match between build and deploy workflows"
          exit 1
        fi
        
        echo "âœ… Image verified: ${{ steps.image.outputs.image }}"
        echo "âœ… Proceeding with deployment"

    - name: Login to Azure
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}

    - name: Generate deployment config
      run: |
        cat > deployment.yaml << EOF
        apiVersion: '2021-10-01'
        location: ${{ vars.AZURE_LOCATION || 'eastus' }}
        name: ${{ vars.AZURE_CONTAINER_NAME || 'trading-course' }}
        properties:
          containers:
          # Main application container
          - name: trading-app
            properties:
              image: ${{ steps.image.outputs.image }}
              ports:
              - protocol: TCP
                port: 8080
              environmentVariables:
              - name: 'MONGODB_URI'
                secureValue: '${{ secrets.MONGODB_URI }}'
              - name: 'CONFIG_FILE'
                value: '${{ vars.CONFIG_FILE || '/config.production.yaml' }}'
              - name: 'PORT'
                value: '8080'
              - name: 'LOG_LEVEL'
                value: '${{ vars.LOG_LEVEL || 'info' }}'
              resources:
                requests:
                  memoryInGB: ${{ vars.MEMORY_GB || 1 }}
                  cpu: ${{ vars.CPU_CORES || 0.5 }}
          # Nginx + Let's Encrypt container
          - name: nginx-ssl
            properties:
              image: nginxproxy/nginx-proxy:alpine
              ports:
              - protocol: TCP
                port: 80
              - protocol: TCP
                port: 443
              environmentVariables:
              - name: 'DEFAULT_HOST'
                value: '${{ vars.DOMAIN_NAME }}'
              - name: 'VIRTUAL_HOST'
                value: '${{ vars.DOMAIN_NAME }}'
              - name: 'VIRTUAL_PORT'
                value: '8080'
              - name: 'LETSENCRYPT_HOST'
                value: '${{ vars.DOMAIN_NAME }}'
              - name: 'LETSENCRYPT_EMAIL'
                value: '${{ vars.LETSENCRYPT_EMAIL || 'admin@' }}${{ vars.DOMAIN_NAME }}'
              volumeMounts:
              - name: nginx-certs
                mountPath: /etc/nginx/certs
              - name: nginx-vhost
                mountPath: /etc/nginx/vhost.d
              - name: nginx-html
                mountPath: /usr/share/nginx/html
               resources:
                 requests:
                   memoryInGB: 0.5
                   cpu: 0.3
          # Let's Encrypt companion
          - name: letsencrypt
            properties:
              image: nginxproxy/acme-companion:latest
              environmentVariables:
              - name: 'DEFAULT_EMAIL'
                value: '${{ vars.LETSENCRYPT_EMAIL || 'admin@' }}${{ vars.DOMAIN_NAME }}'
              volumeMounts:
              - name: nginx-certs
                mountPath: /etc/nginx/certs
              - name: nginx-vhost
                mountPath: /etc/nginx/vhost.d
              - name: nginx-html
                mountPath: /usr/share/nginx/html
              - name: acme-state
                mountPath: /etc/acme.sh
               resources:
                 requests:
                   memoryInGB: 0.3
                   cpu: 0.1
          imageRegistryCredentials:
          - server: ${{ env.REGISTRY }}
            username: ${{ github.actor }}
            password: ${{ secrets.GITHUB_TOKEN }}
          ipAddress:
            type: Public
            ports:
            - protocol: TCP
              port: 80
            - protocol: TCP
              port: 443
            dnsNameLabel: ${{ vars.AZURE_CONTAINER_NAME || 'trading-course' }}
          osType: Linux
          restartPolicy: Always
          volumes:
          - name: nginx-certs
            emptyDir: {}
          - name: nginx-vhost
            emptyDir: {}
          - name: nginx-html
            emptyDir: {}
          - name: acme-state
            emptyDir: {}
        type: Microsoft.ContainerInstance/containerGroups
        EOF

    - name: Deploy container
      run: |
        echo "Deploying with SSL support..."
        
        az container delete \
          --resource-group ${{ vars.AZURE_RESOURCE_GROUP || 'trading-course-rg' }} \
          --name ${{ vars.AZURE_CONTAINER_NAME || 'trading-course' }} \
          --yes || true
        
        sleep 10
        
        az container create \
          --resource-group ${{ vars.AZURE_RESOURCE_GROUP || 'trading-course-rg' }} \
          --file deployment.yaml

    - name: Health check
      run: |
        sleep 60
        
        CONTAINER_NAME="${{ vars.AZURE_CONTAINER_NAME || 'trading-course' }}"
        RESOURCE_GROUP="${{ vars.AZURE_RESOURCE_GROUP || 'trading-course-rg' }}"
        
        for i in {1..5}; do
          STATE=$(az container show \
            --resource-group "$RESOURCE_GROUP" \
            --name "$CONTAINER_NAME" \
            --query 'instanceView.state' \
            --output tsv)
          
          if [ "$STATE" = "Running" ]; then
            echo "âœ… Container is running"
            break
          elif [ "$STATE" = "Failed" ]; then
            echo "âŒ Container failed"
            az container logs --resource-group "$RESOURCE_GROUP" --name "$CONTAINER_NAME"
            exit 1
          fi
          
          echo "Waiting... ($i/5)"
          sleep 20
        done

    - name: Get deployment info
      run: |
        CONTAINER_NAME="${{ vars.AZURE_CONTAINER_NAME || 'trading-course' }}"
        RESOURCE_GROUP="${{ vars.AZURE_RESOURCE_GROUP || 'trading-course-rg' }}"
        
        INFO=$(az container show \
          --resource-group "$RESOURCE_GROUP" \
          --name "$CONTAINER_NAME" \
          --query '{fqdn: ipAddress.fqdn, ip: ipAddress.ip, state: instanceView.state}' \
          --output json)
        
        echo "Container Info:"
        echo "$INFO" | jq
        
        IP=$(echo "$INFO" | jq -r '.ip')
        echo "Set DNS A record: ${{ vars.DOMAIN_NAME || 'your-domain.com' }} -> $IP"

    - name: Extended health check
      id: health_check
      run: |
        CONTAINER_NAME="${{ vars.AZURE_CONTAINER_NAME || 'trading-course' }}"
        RESOURCE_GROUP="${{ vars.AZURE_RESOURCE_GROUP || 'trading-course-rg' }}"
        
        echo "Performing extended health check..."
        
        # Wait for container to be fully ready
        sleep 120
        
        # Check container is still running
        STATE=$(az container show \
          --resource-group "$RESOURCE_GROUP" \
          --name "$CONTAINER_NAME" \
          --query 'instanceView.state' \
          --output tsv)
        
        if [ "$STATE" != "Running" ]; then
          echo "âŒ Container not running: $STATE"
          exit 1
        fi
        
        # Get container info for health check
        INFO=$(az container show \
          --resource-group "$RESOURCE_GROUP" \
          --name "$CONTAINER_NAME" \
          --query '{fqdn: ipAddress.fqdn, ip: ipAddress.ip}' \
          --output json)
        
        FQDN=$(echo "$INFO" | jq -r '.fqdn')
        
        if [ "$FQDN" != "null" ] && [ -n "$FQDN" ]; then
          # Test HTTP endpoint
          echo "Testing HTTP endpoint: http://$FQDN"
          if curl --fail --max-time 30 --retry 3 --retry-delay 10 "http://$FQDN" > /dev/null 2>&1; then
            echo "âœ… HTTP health check passed"
          else
            echo "âš ï¸ HTTP health check failed, but container is running"
          fi
        fi
        
        echo "âœ… Extended health check completed"
        echo "healthy=true" >> $GITHUB_OUTPUT

    - name: Save deployment metadata
      if: steps.health_check.outputs.healthy == 'true'
      run: |
        echo "ðŸ“ Saving deployment metadata..."
        
        cat > deployment-metadata.json << EOF
        {
          "deployment_time": "$(date -u +"%Y-%m-%dT%H:%M:%SZ")",
          "commit_sha": "${{ steps.image.outputs.commit_sha }}",
          "image": "${{ steps.image.outputs.image }}",
          "tag": "${{ steps.image.outputs.tag }}",
          "workflow_run_id": "${{ github.run_id }}",
          "actor": "${{ github.actor }}",
          "ref": "${{ github.ref }}",
          "event": "${{ github.event_name }}"
        }
        EOF
        
        echo "Deployment metadata:"
        cat deployment-metadata.json | jq .

    - name: Upload deployment metadata
      if: steps.health_check.outputs.healthy == 'true'
      uses: actions/upload-artifact@v4
      with:
        name: deployment-metadata-${{ github.run_id }}
        path: deployment-metadata.json

    - name: Promote to stable
      if: steps.health_check.outputs.healthy == 'true' && github.ref == 'refs/heads/main'
      run: |
        echo "ðŸ·ï¸ Promoting deployment to stable tag..."
        
        # Login to registry
        echo ${{ secrets.GITHUB_TOKEN }} | docker login ${{ env.REGISTRY }} -u ${{ github.actor }} --password-stdin
        
        # Current deployment image
        CURRENT_IMAGE="${{ steps.image.outputs.image }}"
        STABLE_IMAGE="${{ env.REGISTRY }}/${{ steps.image_name.outputs.name }}:stable"
        PREVIOUS_STABLE_IMAGE="${{ env.REGISTRY }}/${{ steps.image_name.outputs.name }}:stable-previous"
        
        # Backup current stable tag as stable-previous
        if docker manifest inspect "$STABLE_IMAGE" > /dev/null 2>&1; then
          echo "Backing up current stable as stable-previous..."
          docker pull "$STABLE_IMAGE"
          docker tag "$STABLE_IMAGE" "$PREVIOUS_STABLE_IMAGE"
          docker push "$PREVIOUS_STABLE_IMAGE"
        fi
        
        # Pull and tag the new stable image
        echo "Pulling: $CURRENT_IMAGE"
        docker pull "$CURRENT_IMAGE"
        
        echo "Tagging as stable: $STABLE_IMAGE"
        docker tag "$CURRENT_IMAGE" "$STABLE_IMAGE"
        
        # Push new stable tag
        echo "Pushing stable tag..."
        docker push "$STABLE_IMAGE"
        
        echo "âœ… Successfully promoted ${{ steps.image.outputs.commit_sha }} to stable"
        echo "âœ… Previous stable backed up as stable-previous"

  rollback:
    name: Rollback on failure
    runs-on: ubuntu-latest
    needs: deploy
    if: failure()
    
    steps:
    - name: Login to Azure
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}

    - name: Set rollback image name
      id: rollback_image
      run: echo "name=$(echo '${{ github.repository }}' | tr '[:upper:]' '[:lower:]')" >> $GITHUB_OUTPUT

    - name: Rollback to stable image
      run: |
        echo "Deployment failed, attempting rollback to stable..."
        
        # Try to use stable tag first, fallback to latest
        ROLLBACK_IMAGE="${{ env.REGISTRY }}/${{ steps.rollback_image.outputs.name }}:stable"
        
        # Verify stable image exists
        if ! docker manifest inspect "$ROLLBACK_IMAGE" > /dev/null 2>&1; then
          echo "Stable image not found, using latest..."
          ROLLBACK_IMAGE="${{ env.REGISTRY }}/${{ steps.rollback_image.outputs.name }}:latest"
        fi
        
        echo "Rolling back to: $ROLLBACK_IMAGE"
        
        # Generate rollback deployment config
        cat > rollback-deployment.yaml << EOF
        apiVersion: '2021-10-01'
        location: ${{ vars.AZURE_LOCATION || 'eastus' }}
        name: ${{ vars.AZURE_CONTAINER_NAME || 'trading-course' }}
        properties:
          containers:
          - name: trading-app
            properties:
              image: $ROLLBACK_IMAGE
              ports:
              - protocol: TCP
                port: 8080
              environmentVariables:
              - name: 'MONGODB_URI'
                secureValue: '${{ secrets.MONGODB_URI }}'
              - name: 'CONFIG_FILE'
                value: '${{ vars.CONFIG_FILE || '/config.production.yaml' }}'
              - name: 'PORT'
                value: '8080'
              resources:
                requests:
                  memoryInGB: ${{ vars.MEMORY_GB || 1 }}
                  cpu: ${{ vars.CPU_CORES || 0.5 }}
          imageRegistryCredentials:
          - server: ${{ env.REGISTRY }}
            username: ${{ github.actor }}
            password: ${{ secrets.GITHUB_TOKEN }}
          ipAddress:
            type: Public
            ports:
            - protocol: TCP
              port: 80
            dnsNameLabel: ${{ vars.AZURE_CONTAINER_NAME || 'trading-course' }}
          osType: Linux
          restartPolicy: Always
        type: Microsoft.ContainerInstance/containerGroups
        EOF
        
        # Delete failed container and deploy rollback
        az container delete \
          --resource-group ${{ vars.AZURE_RESOURCE_GROUP || 'trading-course-rg' }} \
          --name ${{ vars.AZURE_CONTAINER_NAME || 'trading-course' }} \
          --yes || true
        
        sleep 10
        
        az container create \
          --resource-group ${{ vars.AZURE_RESOURCE_GROUP || 'trading-course-rg' }} \
          --file rollback-deployment.yaml || echo "âŒ Rollback failed"